"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _name, _client, _query;
const QueriedDocs_1 = __importDefault(require("./QueriedDocs"));
const Document_1 = __importDefault(require("./Document"));
class Collection {
    constructor(client, name) {
        _name.set(this, '');
        _client.set(this, void 0);
        _query.set(this, {});
        /**
         * Assigns the query to be ready before getting the docs
         *
         * @param query object
         *
         * @return self
         */
        this.where = (query) => {
            if (query.id) {
                const { id } = query, all = __rest(query, ["id"]);
                __classPrivateFieldSet(this, _query, Object.assign({ _id: id }, all));
            }
            else {
                __classPrivateFieldSet(this, _query, query);
            }
            return { get: this.get };
        };
        /**
         * Adds a single doc to the collection
         *
         * @param doc object
         *
         * @return Promise<Document>
         */
        this.add = (doc) => new Promise((res, rej) => {
            __classPrivateFieldGet(this, _client).call('post', `/database/${__classPrivateFieldGet(this, _name)}`, {
                'content-type': 'application/json',
            }, { object: doc })
                .then((value) => {
                const _a = value.doc, { _id } = _a, data = __rest(_a, ["_id"]);
                res(new Document_1.default(__classPrivateFieldGet(this, _client), __classPrivateFieldGet(this, _name), _id, data));
            })
                .catch(rej);
        });
        /**
         * Gets a single doc of the collection
         *
         * @param id string
         *
         * @return Promise<Document>
         */
        this.doc = (id) => new Promise((res, rej) => {
            __classPrivateFieldGet(this, _client).call('post', `/database/query/${__classPrivateFieldGet(this, _name)}`, {
                'content-type': 'application/json',
            }, { query: { _id: id } })
                .then((value) => {
                if (value.docs.length !== 0) {
                    const _a = value.docs[0], { _id } = _a, docData = __rest(_a, ["_id"]);
                    res(new Document_1.default(__classPrivateFieldGet(this, _client), __classPrivateFieldGet(this, _name), _id, docData));
                }
                else {
                    rej(new Error(`Couldn't find a doc with the id: ${id}`));
                }
            })
                .catch(rej);
        });
        /**
         * Gets gets all the docs that the where got or all in general
         *
         * @param id string
         *
         * @return Promise<QueriedDocs>
         */
        this.get = () => new Promise((res, rej) => {
            const resQD = (res, data) => {
                const Documents = data.docs.map((doc) => {
                    const { _id } = doc, docData = __rest(doc, ["_id"]);
                    return new Document_1.default(__classPrivateFieldGet(this, _client), __classPrivateFieldGet(this, _name), _id, docData);
                });
                const QD = new QueriedDocs_1.default(__classPrivateFieldGet(this, _query), Documents);
                __classPrivateFieldSet(this, _query, {});
                res(QD);
            };
            if (__classPrivateFieldGet(this, _name) !== '' && __classPrivateFieldGet(this, _query) !== {}) {
                __classPrivateFieldGet(this, _client).call('post', `/database/query/${__classPrivateFieldGet(this, _name)}`, {
                    'content-type': 'application/json',
                }, { query: __classPrivateFieldGet(this, _query) })
                    .then((data) => {
                    resQD(res, data);
                })
                    .catch(rej);
            }
            else if (__classPrivateFieldGet(this, _name) !== '' && __classPrivateFieldGet(this, _query) === {}) {
                __classPrivateFieldGet(this, _client).call('get', `/database/${__classPrivateFieldGet(this, _name)}`)
                    .then((data) => {
                    resQD(res, data);
                })
                    .catch(rej);
            }
            else {
                rej(new Error('Please set a collection name'));
            }
        });
        __classPrivateFieldSet(this, _name, name);
        __classPrivateFieldSet(this, _client, client);
    }
}
_name = new WeakMap(), _client = new WeakMap(), _query = new WeakMap();
module.exports = Collection;
